extends c

snippet mainarg

	#include <iostream>

	using namespace std;

	main( int argc, const char** argv ) -> int
	{
		${1}
		return EXIT_SUCCESS;
	}
# If
# Containers
snippet str
	std::string
snippet cstr
	const std::string&
snippet v
	vector<${1}> ${2}
snippet vi
	vector<int> 
snippet vvi
	vector<vector<int> > 
snippet pii
	pair<int, int> 
snippet vs
	vector<string> 
snippet map
	map<${1:key}, ${2:value}> ${3};
# Constants
snippet eps
	const double EPS = 1e-10;
snippet pi
	const double PI = acos(-1.0);
# Abbrev
snippet ll
	long long 
snippet fst
	first
snippet snd
	second
snippet pb
	push_back(${1:x})${2}
snippet mp
	make_pair(${1}, ${2})${3}
snippet mp12
	make_pair(${1}, make_pair(${2}, ${3}))${4}
snippet mp21
	make_pair(make_pair(${1}, ${2}), ${3})${4}
snippet mp22
	make_pair(make_pair(${1}, ${2}), make_pair(${3}, ${4}))${5}
snippet all
	${1:c}.begin(), $1.end()${2}
snippet rall
	${1:c}.rbegin(), $1.rend()${2}
# Header
snippet inc
	#include <${1:iostream}>${2}
snippet incs
	#include <iostream>
	#include <sstream>
	#include <vector>
	#include <map>
	#include <set>
	#include <queue>
	#include <stack>
	#include <algorithm>
	#include <numeric>
	#include <cstdio>
	#include <cmath>
	#include <cstring>
	using namespace std;
# For debug
snippet debfunc
	template<typename T1, typename T2>
	ostream& operator<<(ostream& s, const pair<T1, T2>& d) {
		return s << "(" << d.first << "," << d.second << ")";
	}

	template<typename T>
	void dump(T x, string label = "") {
		cerr << label << ": " << x << endl;
	}

	template<typename T>
	void dumpv(T x, string label = "") {
		cerr << label << ": ";
		for (int i = 0; i < x.size(); i++) {
			cerr << x[i] << " ";
		}
		cerr << endl;
	}
# Algorithms and Data Structures
snippet gcd
	${1:int} getGCD($1 m, $1 n) {
		if (m < n) swap(m, n);
		while (n) {
			swap(m, n);
			n %= m;
		}
		return m;
	}
snippet unionfind
	class DisjointSet {
	public:
		DisjointSet(int n) {
			rank = vector<int>(n, 0);
			par = vector<int>(n);
			for (int i = 0; i < n; i++) par[i] = i;
		}
		int find(int x) {
			if (x == par[x]) return x;
			else return par[x] = find(par[x]);
		}
		void unite(int x, int y) {
			int rx = find(x), ry = find(y);
			if (rank[rx] < rank[ry]) par[rx] = ry;
			else {
				par[ry] = rx;
				if (rank[rx] == rank[ry]) rank[rx]++;
			}
		}
		bool same(int x, int y) {
			return find(x) == find(y);
		}
	private:
		vector<int> par;
		vector<int> rank;
	};

snippet cerr
	std::cerr << ${1} << std::endl;${2}

snippet cout
	std::cout << ${1} << std::endl;${2}

snippet cin
	std::cin >> ${1};${2}

snippet serr
	cerr << ${1} << endl;
	${2}
snippet sout
	cout << ${1} << endl;${2}
# cin
snippet sin
	cin >> ${1};${2}


snippet mem
	${1:bool} m_${2:bar}; ///< ${3:doc}

snippet vec
	std::vector<${1}> ${2}
# ifndef...define...endif

snippet ndef
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
# define
snippet def
	#define
# ifdef...endif
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif${3}
# if
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# header include guard
snippet guard
	#ifndef ${1:`toupper(Filename('$1_HPP', 'UNTITLED_HPP'))`}
	#define $1
	
	${2:class}

	#endif /* end of include guard: $1 */

snippet fileinfo
	/**
	 * \file   `Filename('$1.hpp', 'Untitled.hpp')`
	 * \brief  Defines class ${1}
	 *
	 * \author Stephan Seitz (stephan.seitz@fau.de)
	 * \date   `system("date +%d.%m.%Y")`
	 */

# switch

snippet using
	using namespace ${1:std};
	${2}

snippet try
	try {
		${2}
	} catch ( ${1:std::exception& exp} ) {
		${3:std::cerr << exp.what() << std::endl;}
	}
	${4}

snippet incopencv
	#include <opencv2/${1:opencv}.hpp>

##
## STL Collections
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	std::vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
##
## STL smart pointers
# std::shared_ptr
snippet msp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp
	auto ${1} = std::make_shared<${2:T}>(${3});
# std::unique_ptr
snippet mup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup
	auto ${1} = std::make_unique<${2:T}>(${3});
##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable
##
## Class
# class
# member function implementation

# member function implementation without parameters
snippet dmfun0
	/*! \brief ${4:Brief function description here}
	 *
	 *  ${5:Detailed description}
	 *
	 * \return ${6:Return parameter description}
	 */
	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() 
	{
		${0}
	}
# member function implementation with one parameter
snippet dmfun1
	/*! \brief ${6:Brief function description here}
	 *
	 *  ${7:Detailed description}
	 *
	 * \param $4 ${8:Parameter description}
	 * \return ${9:Return parameter description}
	 */
	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter})
	{
		${0}
	}
# member function implementation with two parameter
snippet dmfun2
	/*! \brief ${8:Brief function description here}
	 *
	 *  ${9:Detailed description}
	 *
	 * \param $4 ${10:Parameter description}
	 * \param $6 ${11:Parameter description}
	 * \return ${12:Return parameter description}
	 */
	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} // namespace $1
snippet ans
	namespace {
		${0}
	}
##
## Input/Output
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr)}${3}
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:(expr)}${3}
# reinterpret
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr)}${3}
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr)}${3}
## Iteration
# for i
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera
	for (auto ${1:it} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
snippet it
	for (auto ${1:it} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
##
## Lambdas
# lamda (one line)
snippet l
	[${1}](${2}){${3}}
snippet ld
	[${1}](${2}){${3}}
# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	}
# snippets exception
snippet try
	try {

	}catch(${1}) {

	}

snippet af auto function
	auto ${1:name}(${2}) -> ${3:void}
	{
		${0}
	};

snippet m
	${1:int} m_${2:name}; ///< ${3}

snippet qde
	qDebug() << 
